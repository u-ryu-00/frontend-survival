# 3. MSW

## [💡 Service worker](https://developer.mozilla.org/ko/docs/Web/API/Service_Worker_API)

서비스 워커는 웹 응용 프로그램, 브라우저, 그리고 (사용 가능한 경우) 네트워크 사이의 프록시 서버 역할을 한다. 서비스 워커 덕분에 효과적인 오프라인 경험을 생성하고, 네트워크 요청을 가로채서 네트워크 사용 가능 여부에 따라 적절한 행동을 취하고, 서버의 자산을 업데이트할 수 있다. 또한 푸시 알림과 백그라운드 동기화 API로의 접근도 제공한다.

### 서비스 워커의 개념과 사용법

서비스 워커는 출처와 경로에 대해 등록하는 이벤트 기반 워커로서 JavaScript 파일의 형태를 갖고 있다. 서비스 워커는 연관된 웹 페이지/사이트를 통제하여 탐색과 리소스 요청을 가로채 수정하고, 리소스를 굉장히 세부적으로 캐싱할 수 있다. 이를 통해 웹 앱이 어떤 상황에서 어떻게 동작해야 하는지 완벽하게 바꿀 수 있다. (제일 대표적인 상황은 네트워크를 사용하지 못할 때이다.)

서비스 워커는 워커 맥락에서 실행되기 때문에 DOM에 접근할 수 없다. 또한 앱을 구동하는 주 JavaScript와는 다른 스레드에서 동작하므로 연산을 가로막지 않는다(논 블로킹). 서비스 워커는 온전히 비동기적으로 설계됐으며, 그로 인해 동기적 XHR이나 웹 저장소 등의 API를 서비스 워커 내에서 사용할 수 없다.

서비스 워커는 보안 상의 이유로 HTTPS에서만 동작한다. 네트워크 요청을 수정할 수 있다는 점에서 중간자 공격에 굉장히 취약하기 때문이다. 또한 Firefox에서는 사생활 보호 모드에서 Service Worker API에 접근할 수 없다.

### 등록

서비스 워커는 `ServiceWorkerContainer.register() (en-US)` 메서드를 사용해 처음 등록한다. 성공적으로 등록한 경우 클라이언트가 서비스 워커를 다운로드하고, 출처 전체에 대해 혹은 개발자가 지정한 특정 주소들에 대해서 서비스 워커의 설치와 활성화를 시도한다.

### 다운로드, 설치, 활성화

서비스 워커를 살펴보면 다음과 같은 생명주기를 볼 수 있습니다.

1. 다운로드
2. 설치
3. 활성화

서비스 워커가 제어하는 사이트/페이지에 사용자가 처음 접근하는 순간 서비스 워커가 즉시 다운로드 된다.

서비스 워커의 업데이트는 다음 경우에 발생한다.

- 범위 내 페이지로의 탐색 발생
- 서비스 워커에서 이벤트가 발생했는데, 서비스 워커를 이전 24시간 내에 다운로드하지 않은 경우

다운로드한 파일이 더 새로운 버전인 경우 서비스 워커의 설치를 시도한다. 버전 비교는 기존 서비스 워커 파일과의 바이트 단위 비교 결과를 사용한다. 이 페이지/사이트에서 서비스 워커를 처음 발견한 경우에도 "새로운 버전"으로 취급한다.

기존 서비스 워커가 없으면 설치를 시도하고, 설치를 성공하면 활성화한다.

기존에 서비스 워커가 존재하던 경우, 새로운 버전을 백그라운드에서 설치하지만 활성화는 아직 하지 않는다. 이 시점의 워커를 대기 중인 워커라고 부른다. 대기 중인 워커는 이전 버전의 서비스 워커를 사용하는 페이지가 모두 닫힌 경우 활성화되어 활성 워커가 된다. `ServiceWorkerGlobalScope.skipWaiting()`을 사용해 활성화 절차를 더 빨리 시작할 수 있으며, 새로운 활성 워커는 `Clients.claim()`을 사용해 이전 페이지를 회수할 수 있다.

생명주기 중 발생하는 이벤트 중 하나는 `install (en-US)` 이벤트이다. 이 이벤트의 대표적인 사용 방법은, 예를 들면 내장 저장소 API를 사용해 캐시를 만들고, 오프라인 상황에서 사용할 자산을 준비하는 등, 서비스 워커의 사용을 준비하는 것이다.

`activate (en-US)` 이벤트도 있다. `activate`의 시점에서는 과거의 캐시를 지우고, 구버전 서비스 워커에 관련된 항목을 청소하는 등 여러가지를 정리하기에 좋다.

서비스 워커는 `FetchEvent (en-US)` 이벤트를 사용해 요청에 응답할 수 있다. `FetchEvent.respondWith() (en-US)` 메서드를 사용해 요청에 대한 응답을 원하는 방식으로 자유롭게 바꾸면 된다.

## [💡 MSW(Mock Service Worker) : 차세대 API mocking](https://mswjs.io/)

![MSW](../week5/images/msw.png)

```bash
코드 레벨이 아니라 네트워크 레벨에서 가짜 구현.  
오프라인 작업 등을 지원하기 위한 서비스 워커의 기능을 유용히 활용한 것.
```

네트워크 수준에서 요청을 가로채서 모의 테스트하라. 테스트, 개발, 디버깅에 동일한 mock definition을 원활하게 재사용할 수 있다.

Mock Service Worker는 Service Worker API를 사용하여 실제 요청을 가로채는 API mocking library이다.

Mock Service Worker는 캐싱을 목적으로 요청을 캡처할 수 있는 Service Worker의 기능을 제공함으로써 네트워크 통신 체인의 최상위 수준에서 API 모킹을 가능하게 한다. 모의 서버를 생성하지 않고도 모의 서버에 가장 근접한 기능을 제공한다.

Service Worker는 모든 최신 브라우저에서 제공하는 표준 API이므로, 애플리케이션에 Mock Service Worker를 통합하거나 설정을 테스트할 때 별도의 구성 없이 워커 파일을 배치하고 모의 서버를 선언하기만 하면 된다.

### [특징](https://github.com/mswjs/msw)

- 원활하다.  
요청을 차단하는 전용 계층을 마음대로 사용할 수 있다. 애플리케이션의 코드와 테스트가 모킹되는지 여부를 알 수 없도록 하라.
- 편차가 없다.  
동일한 프로덕션 리소스를 요청하고 앱의 실제 동작을 테스트하라. 기존 API를 보강하거나 API가 없는 경우 원하는 대로 설계할 수 있다.
- 친숙하고 강력하다.  
Express와 유사한 라우팅 구문을 사용하여 요청을 캡처하라. 매개변수, 와일드카드, 정규식을 사용하여 요청을 일치시키고 필요한 상태 코드, 헤더, 쿠키, 지연 또는 완전히 사용자 정의된 resolver로 응답할 수 있다.

## [💡 polyfill(폴리필)](https://ko.wikipedia.org/wiki/%ED%8F%B4%EB%A6%AC%ED%95%84_(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D))

폴리필(polyfill)은 웹 개발에서 기능을 지원하지 않는 웹 브라우저 상의 기능을 구현하는 코드를 뜻한다.  
기능을 지원하지 않는 웹 브라우저에서 원하는 기능을 구현할 수 있으나, 폴리필 플러그인 로드 때문에 시간과 트래픽이 늘어나고, 브라우저별 기능을 추가하는 것 때문에 코드가 매우 길어지고, 성능이 많이 저하된다는 단점이 있다.

### 폴리필 예시

- HTML5 shiv  
인터넷 익스플로러 9 이하에서 시맨틱 태그를 지원하도록 한다.
- CSS3 PIE  
인터넷 익스플로러 9 이하에서 CSS3 둥근 모서리(border-radius) 속성을 지원하도록 한다.
- FlashCanvas  
캔버스를 지원하지 않는 인터넷 익스플로러 8 이하에서 HTML5 캔버스를 인터넷 익스플로러 8 이하에 맞는 플래시 오브젝트로 바꾸어 나타내 준다.
- MediaElement.js  
audio/video 태그를 지원하지 않는 브라우저에서, 해당 태그를 플래시로 바꾸어 표시한다.
- Flexie  
Flex를 지원하지 않는 구형 브라우저에서 Flex CSS 옵션을 지원하도록 한다.

### [GitHub에서 만든 fetch polyfill](https://github.com/JakeChampion/fetch)

fetch() 함수는 브라우저에서 프로그래밍 방식으로 웹 요청을 하기 위한 프로미스 기반 메커니즘이다. 이 프로젝트는 표준 Fetch 사양의 하위 집합을 구현하는 폴리필로, 기존 웹 애플리케이션에서 XMLHttpRequest를 대부분 대체할 수 있을 정도로 fetch를 구현한다.
